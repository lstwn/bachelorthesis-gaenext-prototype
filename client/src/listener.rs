use crate::state::Event;
use anyhow::{Context, Result};
use exposurelib::logger;
use exposurelib::rpcs::{ForwardParams, Forwarder};
use futures::{future, prelude::*};
use std::net::SocketAddr;
use std::time::Duration;
use tarpc::server::{self, Channel, Incoming};
use tarpc::tokio_serde::formats;
use tokio::sync::mpsc;
use tokio::sync::oneshot;
use tokio::time;

pub struct Listener {
    address: SocketAddr,
    requests: mpsc::Receiver<Duration>,
    client_state: mpsc::Sender<Event>,
}

impl Listener {
    pub fn new(
        address: SocketAddr,
        requests: mpsc::Receiver<Duration>,
        client_state: mpsc::Sender<Event>,
    ) -> Self {
        Self {
            address,
            requests,
            client_state,
        }
    }
    pub async fn run(mut self) -> ! {
        loop {
            let duration = match self.requests.recv().await {
                Some(duration) => duration,
                None => panic!("Listener's send end closed"),
            };
            let address = self.address;
            let client_state = self.client_state.clone();
            let listener_result = tokio::select! {
                _ = self.timeout(duration) => Ok(()),
                result = Self::listen(address, client_state) => result,
            };
            if let Err(e) = listener_result {
                logger::warn!("Error spawning listener: {}", e);
            }
        }
    }
    async fn timeout(&mut self, mut timeout: Duration) -> () {
        loop {
            let next_timeout = tokio::select! {
                _ = time::sleep(timeout) => None,
                next_timeout = self.requests.recv() => next_timeout,
            };
            match next_timeout {
                Some(next_timeout) => {
                    timeout = next_timeout;
                    logger::info!("Renewing listen for next {:?}", timeout);
                    continue;
                }
                None => {
                    logger::info!("Stopping listen");
                    break;
                }
            }
        }
    }
    pub async fn listen(address: SocketAddr, client_state: mpsc::Sender<Event>) -> Result<()> {
        let mut listener = tarpc::serde_transport::tcp::listen(&address, formats::Bincode::default)
            .await
            .context("Error creating TCP Bincode listener")?;
        listener.config_mut().max_frame_length(usize::MAX);

        logger::info!("Starting to listen for forwardable TEKs at {:?}", address);

        listener
            // ignore accept errors
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // just one channel per *ip/port combo* (instead of per ip) in our simulation case
            .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap())
            // function serve() is generated by the service attribute
            // it takes as input any type implementing the generated service trait
            .map(|channel| {
                let server = Handler::new(
                    channel.as_ref().as_ref().peer_addr().unwrap(),
                    client_state.clone(),
                );
                channel.requests().execute(server.serve())
            })
            // max 100 channels (i.e. clients)
            .buffer_unordered(100)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}

#[derive(Clone)]
struct Handler {
    peer_addr: SocketAddr,
    client_state: mpsc::Sender<Event>,
}

impl Handler {
    pub fn new(peer_addr: SocketAddr, client_state: mpsc::Sender<Event>) -> Self {
        Self {
            peer_addr,
            client_state,
        }
    }
}

#[tarpc::server]
impl Forwarder for Handler {
    async fn forward(self, context: tarpc::context::Context, params: ForwardParams) -> () {
        logger::trace!(
            "New forward() RPC from {:?} with context {:?} and params {:?}",
            self.peer_addr,
            context,
            params
        );
        let (tx, rx) = oneshot::channel();
        self.client_state
            .send(Event::NewForwardRequest { params, resp: tx })
            .await
            .unwrap();
        if let Err(e) = rx.await {
            logger::warn!("Error while forwarding TEK: {:?}", e);
        }
    }
}
